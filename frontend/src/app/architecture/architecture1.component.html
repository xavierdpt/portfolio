<p>This website implements an architecture that I present here.</p>

<p>It uses Angular JS, Typescript, redux and redux-ng, immutablejs, reselect, normalizr on the frontend, and some usual Java EE on the backend, and jsweet for the data bridge.</p>

<p>The number of JavaScript frameworks is numerous, but Angular JS is one of the most actively developped today.
In addition, the archetype generated by the @angular/cli uses TypeScript which allows for compile time error checking in Visual Studio Code without requiring any additional setup, and provides some configuration for unit testing and a live reload environment for a fast development cycle.</p>

<p>But AngularJS is not enough. One problem that is present in both React and AngularJS project is state management. For some reason, the state management problem was first addressed in React, which lead to the rise in popularity of the Redux. But Angular JS also suffers this problem. This is why this architecture uses redux to address the state management problem.</p>

<p>But the introduction of redux raises it's own set of problems, the source of which is the requirement to have immutable state data. The naive solution to immutability requires duplicating the whole state with some modifications for every changes, which is impractical. The solution to this is immutablejs.</p>

<p>One core principle of state management programs is to have only one single source of truth. This seems nice, until the need for functional depencies comes. The solution to this is reselect.</p>

<p>Another problem is the need for efficiently using the same data in different ways. For example, one may want to display a list of items in a specific order, and use a list of objects for that. But then, the need to access an object by identifier requires scanning the whole list, which is inefficient and time consuming both inefficient to write and inefficient to run. The solution to this is normalizr.</p>

<p>Combining redux, immutablejs, reselect and normalizr together is a quite popular setup.</p>

<p>In so far as frontend development is concerned, the setup is complete. But this frontend has to communicate with the backend, and pass in some input objects and get back some output objects. In many seutps, these objects are usually defined in Java, and used withtout schema on the frontend, which introduces maintanbility problems.</p>

<p>This project uses jsweet to convert the Java objects of the backend to TypeScript, so that the frontend can references these generated TypeScript objects. This way, any modifications of the objects can be detected and propagated in the frontend develpoment environement.</p>

<p>One issue that comes with this architecture is that two servers are used at development time. One is the live reload of the frontend, and the other is the backend server. These servers talks on different port, which raises CORS issues, and it would be unwise to include CORS information on the backend just to make the development frontend server talk to the development backend server.</p>
